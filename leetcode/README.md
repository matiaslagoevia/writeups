# Leetcode

My solutions to some Leetcode problems.

| **problem**                                                              | **takeaway**                                                                                                                                                                     |
| ------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [217. Contains Duplicate](217_contains-duplicate.md)                     | `Set`s help with unique elements/constraints; `O(1)` insertion and searching.                                                                                                    |
| [242. Valid Anagram](242_valid-anagram.md)                               | freq array trick on small & contiguous ranges vs `Map`s.                                                                                                                         |
| [1. Two Sum](1_two-sum.md)                                               | check first then add avoids counting same index on single pass.                                                                                                                  |
| [49. Group Anagrams](49_group-anagrams.md)                               | don't use arrays as map keys because of reference issues; favor counting sort over other approaches if possible to avoid log factor.                                             |
| [541. Reverse String II](541_reverse-string-ii.md)                       | strings immutable, use `.split()` and `.join()` to move b/w array & string; last range `r=min(n-1, i+len-1)`.                                                                    |
| [22. Generate Parentheses](22_generate-parentheses.md)                   | stack unnecessary, order of checks matters for validity (`open < n` followed by `closed < open`)                                                                                 |
| [937. Reorder Data in Log Files](937_reorder-data-in-log-files.md)       | spread syntax; `s1.localeCompare(s2)`; `Number(s)` & `isNaN()`; `s.slice()` and `s.indexOf()`                                                                                    |
| [347. Top K Frequent Elements](347_top-k-frequent-elements.md)           | `.get() \|\| default` idea; spreading operator; freq map for counts, buckets for grouping counts, reverse iteration for k best.                                                  |
| [832. Flipping an Image](832_flipping-an-image.md)                       | possibility of using `map` & `reverse` for one-liner; realizing reversal & inversion could be done at the same time.                                                             |
| [872. Leaf Similar Trees](872_leaf-similar-trees.md)                     | terminating 2nd dfs early if not matching current 1st leaf sequence; checking for extra unprocessed trailing leafs; recursive dfs w/ boolean returns based on first/second pass. |
| [238. Product of Array Except Self](238_product-of-array-except-self.md) | left/pre vs right/post product in different arrays; separate loops operating on result directly, variable vs keeping old values.                                                 |
| [59. Spiral Matrix II](59_spiral-matrix-ii.md)                           | 2d array; following the spiral movement and then adjusting for the next one.                                                                                                     |
| [994. Rotting Oranges](994_rotting-oranges.md)                           | bfs, iterative, multiple starting points, non-visited array/in-place mutation.                                                                                                   |
| [36. Valid Sudoku](36_valid-sudoku.md)                                   | array subgrids [i//3][j//3]; check rows & subgrids, then cols; use arrays over sets for narrow ranges if possible.                                                               |
| [271. Encode and Decode Strings](271_encode-and-decode-strings.md)       | trivial split-and-join outside alphabet; non-trivial escaping of separator and word processing on decode; JS no array OOB, simplifies word processing implementation.            |
| [290. Word Pattern](290_word-pattern.md)                                 | associating a letter to a word (map) and keeping track of map values in a set to know at insertion time if a different key holds the same value.                                 |
| [128. Longest Consecutive Sequence](128_longest-consecutive-sequence.md) | hashset only considering possible starting points (`!s.has(x-1)`) for a sequence and growing only from those (`while(s.has(x+1))`) for `O(N)` time.                              |
| [1302. Deepest Leaves Sum](1302_deepest-leaves-sum.md)                   | DFS that keeps track of the values at the max depth and then sums all the values.                                                                                                |
